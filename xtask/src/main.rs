mod zip_ext;

use std::{
    env,
    fs::{self, File},
    io::{BufRead, BufReader, Write},
    path::{Path, PathBuf},
    process::Command,
};

use anyhow::{Context, Result};
use clap::{Parser, Subcommand};
use fs_extra::dir;
use zip::{write::FileOptions, CompressionMethod};

use crate::zip_ext::zip_create_from_directory_with_options;

#[derive(Parser)]
#[command(name = "xtask")]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Build the full project (zakosign disabled temporarily)
    Build {
        /// Build in release mode
        #[arg(long)]
        release: bool,
        /// (Disabled) Path to signing private key
        #[arg(long)]
        sign_key: Option<PathBuf>,
    },
}

fn main() -> Result<()> {
    let cli = Cli::parse();
    let root = project_root();

    match cli.command {
        // We ignore sign_key with `_` since zakosign is disabled
        Commands::Build { release, sign_key: _ } => {
            let output_dir = root.join("output");
            let module_build_dir = output_dir.join("module_files");

            // 1. Clean & Setup
            println!(":: Cleaning output directory...");
            if output_dir.exists() {
                fs::remove_dir_all(&output_dir)?;
            }
            fs::create_dir_all(&module_build_dir)?;

            // 2. Generate Shared Constants (SSOT)
            // This ensures WebUI uses the exact paths and data defined in Rust.
            generate_js_constants(&root)?;

            // 3. Build WebUI
            build_webui(&root)?;

            // 4. Build Zakosign (Host Tool) - [DISABLED]
            let _zakosign_bin: Option<PathBuf> = None; 

            // 5. Build Core (Android)
            let core_bin = build_core(&root, release)?;

            // 6. Copy Module Files
            println!(":: Copying module files...");
            let module_src = root.join("module");
            dir::copy(
                &module_src,
                &module_build_dir, 
                &dir::CopyOptions::new().overwrite(true).content_only(true),
            )?;
            
            // Cleanup gitignore
            let gitignore = module_build_dir.join(".gitignore");
            if gitignore.exists() { fs::remove_file(gitignore)?; }

            // 7. Inject Version
            let version = inject_version(&module_build_dir)?;
            fs::write(output_dir.join("version"), &version)?;

            // 8. Install Core Binary
            let dest_bin = module_build_dir.join("meta-hybrid");
            fs::copy(&core_bin, &dest_bin)?;

            // 9. Zip Package
            println!(":: Creating zip archive...");
            let options = FileOptions::default()
                .compression_method(CompressionMethod::Deflated)
                .compression_level(Some(9));
            
            let zip_name = format!("meta-hybrid-{}.zip", version);
            let zip_path = output_dir.join(zip_name);
            
            // Zip creates from module_build_dir
            zip_create_from_directory_with_options(
                &zip_path,
                &module_build_dir,
                |_| options,
            )?;

            println!(":: Build success: {}", zip_path.display());
        }
    }

    Ok(())
}

fn project_root() -> PathBuf {
    Path::new(&env!("CARGO_MANIFEST_DIR"))
        .ancestors()
        .nth(1)
        .unwrap()
        .to_path_buf()
}

/// Parses Rust source files to extract constants and generates a JS file for WebUI.
fn generate_js_constants(root: &Path) -> Result<()> {
    println!(":: Generating shared constants for WebUI...");

    // Map Rust constant names to WebUI keys
    // Format: (Rust Constant Name, WebUI Key Name, Source File Relative Path)
    let path_mappings = [
        ("CONFIG_FILE_DEFAULT", "CONFIG", "src/conf/config.rs"),
        ("MODULE_MODE_FILE", "MODE_CONFIG", "src/conf/config.rs"),
        ("FALLBACK_CONTENT_DIR", "IMAGE_MNT", "src/defs.rs"),
        ("STATE_FILE", "DAEMON_STATE", "src/defs.rs"),
        ("DAEMON_LOG_FILE", "DAEMON_LOG", "src/defs.rs"),
    ];

    let mut js_content = String::from("// This file is auto-generated by xtask. DO NOT EDIT.\n\n");
    
    // 1. Export Paths
    js_content.push_str("export const RUST_PATHS = {\n");
    for (rust_const, js_key, file_rel_path) in path_mappings {
        let file_path = root.join(file_rel_path);
        let value = extract_str_constant(&file_path, rust_const)
            .with_context(|| format!("Failed to find constant {} in {}", rust_const, file_rel_path))?;
        
        // Remove trailing slash for consistency if needed, but for now we keep exact match
        let clean_val = value.trim_end_matches('/');
        
        js_content.push_str(&format!("  {}: \"{}\",\n", js_key, clean_val));
    }
    js_content.push_str("};\n\n");

    // 2. Export Partitions List
    let defs_path = root.join("src/defs.rs");
    let partitions = extract_array_constant(&defs_path, "BUILTIN_PARTITIONS")
        .context("Failed to extract BUILTIN_PARTITIONS")?;
    js_content.push_str(&format!("export const BUILTIN_PARTITIONS = {};\n", partitions));

    let output_path = root.join("webui/src/lib/constants_gen.js");
    let mut file = File::create(&output_path)?;
    file.write_all(js_content.as_bytes())?;

    println!(":: Generated: {}", output_path.display());
    Ok(())
}

/// Simple parser to extract string constant value from Rust code
/// Looks for: pub const NAME: &str = "VALUE";
fn extract_str_constant(path: &Path, const_name: &str) -> Result<String> {
    let file = File::open(path)?;
    let reader = BufReader::new(file);

    for line in reader.lines() {
        let line = line?;
        let trimmed = line.trim();
        if trimmed.starts_with("pub const") && trimmed.contains(const_name) {
            // Naive parsing: split by double quotes
            let parts: Vec<&str> = trimmed.split('"').collect();
            if parts.len() >= 2 {
                return Ok(parts[1].to_string());
            }
        }
    }
    anyhow::bail!("Constant {} not found", const_name)
}

/// Simple parser to extract array constant value from Rust code
/// Looks for: pub const NAME: &[&str] = &["a", "b"];
/// Returns the JSON-compatible array string ["a", "b"]
fn extract_array_constant(path: &Path, const_name: &str) -> Result<String> {
    let file = File::open(path)?;
    let reader = BufReader::new(file);

    for line in reader.lines() {
        let line = line?;
        let trimmed = line.trim();
        if trimmed.starts_with("pub const") && trimmed.contains(const_name) {
            // Extract content after '='
            if let Some(eq_idx) = trimmed.find('=') {
                let content = &trimmed[eq_idx+1..].trim();
                // Strip starting '&' reference marker if present
                let content = content.strip_prefix('&').unwrap_or(content);
                // Strip trailing semicolon
                let content = content.trim_end_matches(';');
                return Ok(content.to_string());
            }
        }
    }
    anyhow::bail!("Constant array {} not found", const_name)
}

fn build_webui(root: &Path) -> Result<()> {
    println!(":: Building WebUI...");
    let webui_dir = root.join("webui");
    let npm = if cfg!(windows) { "npm.cmd" } else { "npm" };

    let status = Command::new(npm)
        .current_dir(&webui_dir)
        .arg("install")
        .status()?;
    if !status.success() { anyhow::bail!("npm install failed"); }

    let status = Command::new(npm)
        .current_dir(&webui_dir)
        .args(["run", "build"])
        .status()?;
    if !status.success() { anyhow::bail!("npm run build failed"); }

    Ok(())
}

fn build_core(root: &Path, release: bool) -> Result<PathBuf> {
    println!(":: Building Meta-Hybrid Core (aarch64-linux-android)...");
    
    let mut cmd = Command::new("cargo");
    cmd.current_dir(root)
       .args(["ndk", "--platform", "30", "-t", "arm64-v8a", "build"]);
    
    if release {
        cmd.arg("--release");
    }
    
    cmd.env("RUSTFLAGS", "-C default-linker-libraries");
    
    let status = cmd.status()?;
    if !status.success() { anyhow::bail!("Cargo build failed"); }

    let profile = if release { "release" } else { "debug" };
    let bin_path = root.join("target/aarch64-linux-android")
        .join(profile)
        .join("meta-hybrid");
        
    if !bin_path.exists() {
        anyhow::bail!("Core binary not found at {}", bin_path.display());
    }

    Ok(bin_path)
}

fn inject_version(target_dir: &Path) -> Result<String> {
    let output = Command::new("git")
        .args(["rev-parse", "--short", "HEAD"])
        .output();

    let hash = match output {
        Ok(o) if o.status.success() => String::from_utf8(o.stdout)?.trim().to_string(),
        _ => "unknown".to_string(),
    };

    let prop_path = target_dir.join("module.prop");
    let mut full_version = format!("v0.0.0-g{}", hash);

    if prop_path.exists() {
        let content = fs::read_to_string(&prop_path)?;
        let mut new_lines = Vec::new();
        
        for line in content.lines() {
            if line.starts_with("version=") {
                let base = line.trim().strip_prefix("version=").unwrap_or("");
                full_version = format!("{}-g{}", base, hash);
                new_lines.push(format!("version={}", full_version));
            } else {
                new_lines.push(line.to_string());
            }
        }
        
        fs::write(prop_path, new_lines.join("\n"))?;
        println!(":: Injected version: {}", full_version);
    }
    
    Ok(full_version)
}
